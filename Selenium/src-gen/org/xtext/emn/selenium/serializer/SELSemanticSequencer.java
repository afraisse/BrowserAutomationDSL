/*
 * generated by Xtext
 */
package org.xtext.emn.selenium.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.emn.selenium.sel.Affectation;
import org.xtext.emn.selenium.sel.BinaryCondition;
import org.xtext.emn.selenium.sel.Check;
import org.xtext.emn.selenium.sel.Click;
import org.xtext.emn.selenium.sel.DoWhile;
import org.xtext.emn.selenium.sel.Exec;
import org.xtext.emn.selenium.sel.Fill;
import org.xtext.emn.selenium.sel.ForAll;
import org.xtext.emn.selenium.sel.GetButton;
import org.xtext.emn.selenium.sel.GetButtons;
import org.xtext.emn.selenium.sel.GetCheckbox;
import org.xtext.emn.selenium.sel.GetCheckboxes;
import org.xtext.emn.selenium.sel.GetLink;
import org.xtext.emn.selenium.sel.GetLinks;
import org.xtext.emn.selenium.sel.GetText;
import org.xtext.emn.selenium.sel.GoTo;
import org.xtext.emn.selenium.sel.IfThenElse;
import org.xtext.emn.selenium.sel.Program;
import org.xtext.emn.selenium.sel.SelPackage;
import org.xtext.emn.selenium.sel.Sequence;
import org.xtext.emn.selenium.sel.Test;
import org.xtext.emn.selenium.sel.UnaryCondition;
import org.xtext.emn.selenium.sel.Variable;
import org.xtext.emn.selenium.sel.Verify;
import org.xtext.emn.selenium.services.SELGrammarAccess;

@SuppressWarnings("all")
public class SELSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SELGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == SelPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case SelPackage.AFFECTATION:
				sequence_Affectation(context, (Affectation) semanticObject); 
				return; 
			case SelPackage.BINARY_CONDITION:
				sequence_BinaryCondition(context, (BinaryCondition) semanticObject); 
				return; 
			case SelPackage.CHECK:
				sequence_Check(context, (Check) semanticObject); 
				return; 
			case SelPackage.CLICK:
				sequence_Click(context, (Click) semanticObject); 
				return; 
			case SelPackage.DO_WHILE:
				sequence_DoWhile(context, (DoWhile) semanticObject); 
				return; 
			case SelPackage.EXEC:
				sequence_Exec(context, (Exec) semanticObject); 
				return; 
			case SelPackage.FILL:
				sequence_Fill(context, (Fill) semanticObject); 
				return; 
			case SelPackage.FOR_ALL:
				sequence_ForAll(context, (ForAll) semanticObject); 
				return; 
			case SelPackage.GET_BUTTON:
				sequence_GetButton(context, (GetButton) semanticObject); 
				return; 
			case SelPackage.GET_BUTTONS:
				sequence_GetButtons(context, (GetButtons) semanticObject); 
				return; 
			case SelPackage.GET_CHECKBOX:
				sequence_GetCheckbox(context, (GetCheckbox) semanticObject); 
				return; 
			case SelPackage.GET_CHECKBOXES:
				sequence_GetCheckboxes(context, (GetCheckboxes) semanticObject); 
				return; 
			case SelPackage.GET_LINK:
				sequence_GetLink(context, (GetLink) semanticObject); 
				return; 
			case SelPackage.GET_LINKS:
				sequence_GetLinks(context, (GetLinks) semanticObject); 
				return; 
			case SelPackage.GET_TEXT:
				sequence_GetText(context, (GetText) semanticObject); 
				return; 
			case SelPackage.GO_TO:
				sequence_GoTo(context, (GoTo) semanticObject); 
				return; 
			case SelPackage.IF_THEN_ELSE:
				sequence_IfThenElse(context, (IfThenElse) semanticObject); 
				return; 
			case SelPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case SelPackage.SEQUENCE:
				sequence_Sequence(context, (Sequence) semanticObject); 
				return; 
			case SelPackage.TEST:
				sequence_Test(context, (Test) semanticObject); 
				return; 
			case SelPackage.UNARY_CONDITION:
				sequence_UnaryCondition(context, (UnaryCondition) semanticObject); 
				return; 
			case SelPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case SelPackage.VERIFY:
				sequence_Verify(context, (Verify) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (variable=Variable elem=Elem)
	 */
	protected void sequence_Affectation(EObject context, Affectation semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, SelPackage.Literals.AFFECTATION__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SelPackage.Literals.AFFECTATION__VARIABLE));
			if(transientValues.isValueTransient(semanticObject, SelPackage.Literals.AFFECTATION__ELEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SelPackage.Literals.AFFECTATION__ELEM));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAffectationAccess().getVariableVariableParserRuleCall_0_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getAffectationAccess().getElemElemParserRuleCall_2_0(), semanticObject.getElem());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (elem=Elem op=BinaryOp (value=STRING | param=[Variable|ID]))
	 */
	protected void sequence_BinaryCondition(EObject context, BinaryCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (checkbox=GetCheckbox | checkbox=[Variable|ID])
	 */
	protected void sequence_Check(EObject context, Check semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (elem=Elem | elem=[Variable|ID])
	 */
	protected void sequence_Click(EObject context, Click semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (body+=Instruction* condition=Condition)
	 */
	protected void sequence_DoWhile(EObject context, DoWhile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (sequence=[Sequence|ID] (params+=STRING params+=STRING*)?)
	 */
	protected void sequence_Exec(EObject context, Exec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (field=STRING (value=STRING | param=[Variable|ID]))
	 */
	protected void sequence_Fill(EObject context, Fill semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (elems=Elems it=Variable body+=Instruction*)
	 */
	protected void sequence_ForAll(EObject context, ForAll semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value=STRING | var=[Variable|ID])
	 */
	protected void sequence_GetButton(EObject context, GetButton semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value=STRING | var=[Variable|ID])
	 */
	protected void sequence_GetButtons(EObject context, GetButtons semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value=STRING | var=[Variable|ID])
	 */
	protected void sequence_GetCheckbox(EObject context, GetCheckbox semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value=STRING | var=[Variable|ID])
	 */
	protected void sequence_GetCheckboxes(EObject context, GetCheckboxes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value=STRING | var=[Variable|ID])
	 */
	protected void sequence_GetLink(EObject context, GetLink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value=STRING | var=[Variable|ID])
	 */
	protected void sequence_GetLinks(EObject context, GetLinks semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value=STRING | var=[Variable|ID])
	 */
	protected void sequence_GetText(EObject context, GetText semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value=STRING | link=[Variable|ID] | link=GetLink)
	 */
	protected void sequence_GoTo(EObject context, GoTo semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (condition=Condition then+=Instruction* else+=Instruction*)
	 */
	protected void sequence_IfThenElse(EObject context, IfThenElse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (sequences+=Sequence | tests+=Test)*
	 */
	protected void sequence_Program(EObject context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID (parameters+=Variable parameters+=Variable*)? body+=Instruction*)
	 */
	protected void sequence_Sequence(EObject context, Sequence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (browser=STRING body+=Instruction*)
	 */
	protected void sequence_Test(EObject context, Test semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (op=UnaryOp (elem=Elem | elem=[Variable|ID]))
	 */
	protected void sequence_UnaryCondition(EObject context, UnaryCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Variable(EObject context, Variable semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, SelPackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SelPackage.Literals.VARIABLE__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     condition=Condition
	 */
	protected void sequence_Verify(EObject context, Verify semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, SelPackage.Literals.VERIFY__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SelPackage.Literals.VERIFY__CONDITION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getVerifyAccess().getConditionConditionParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.finish();
	}
}
